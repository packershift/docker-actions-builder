image: docker:19.03.12

variables:

   # When you use the dind service, you must instruct Docker to talk with
   # the daemon started inside of the service. The daemon is available
   # with a network connection instead of the default
   # /var/run/docker.sock socket. Docker 19.03 does this automatically
   # by setting the DOCKER_HOST in
   # https://github.com/docker-library/docker/blob/d45051476babc297257df490d22cbd806f1b11e4/19.03/docker-entrypoint.sh#L23-L29
   #
   # The 'docker' hostname is the alias of the service container as described at
   # https://docs.gitlab.com/ee/ci/services/#accessing-the-services.
   #
   # Specify to Docker where to create the certificates. Docker
   # creates them automatically on boot, and creates
   # `/certs/client` to share between the service and job
   # container, thanks to volume mount from config.toml
   DOCKER_TLS_CERTDIR: "/certs"

{% for project_ci_var in project_ci_vars %}
{% for k,v in project_ci_var.items() %}
   {{ k }}: '{{ v }}'
{% endfor %}
{% endfor %}

services:
   - docker:19.03.12-dind

stages:
   - prepare
   - build
   - registry-setup
     
default:
   before_script:
      - apk add jq
      - apk add curl
      - apk add make

package-version-tag:
   stage: prepare
   script:
   - >
      PACKAGE_VERSION_TAG=$(if [ -e package_versions.txt ] ; then
                               cat package_versions.txt | md5sum | cut -c1-8
                            else
                               echo none
                            fi) 
      echo "PACKAGE_VERSION_TAG=$PACKAGE_VERSION_TAG" >> build.env
   artifacts:
    reports:
      dotenv: build.env

release-notes:
   stage: prepare
   script:
   - >
     RELEAESE_NOTES=$(cat readme-config.yml | awk -F \\" '/date: "[0-9][0-9].[0-9][0-9].[0-9][0-9]:/ {print $4;exit;}' | sed -E ':a;N;$!ba;s/\\r{0,1}\\n/\\\\n/g')
     echo "RELEAESE_NOTES=$RELEAESE_NOTES" >> build.env
   artifacts:
    reports:
      dotenv: build.env

build-image:
   stage: build
   script:
   - >
      DOCKER_BUILDKIT=1 docker build
      --label "org.opencontainers.image.created=${CI_COMMIT_TIMESTAMP}" 
      --label "org.opencontainers.image.authors={{ CI_PROJECT_DOMAIN }}" 
      --label "org.opencontainers.image.url={{ CI_PROJECT_URL }}/container_registry" 
      --label "org.opencontainers.image.documentation={{ CI_PROJECT_DOCS_URL }}/images/docker-{{ CI_PROJECT_NAME }}" 
      --label "org.opencontainers.image.source={{ CI_PROJECT_URL }}" 
      --label "org.opencontainers.image.revision=${CI_COMMIT_SHA}" 
      --label "org.opencontainers.image.vendor={{ CI_PROJECT_DOMAIN }}" 
      --label "org.opencontainers.image.licenses={{ CI_PROJECT_LICENSE }}" 
      --label "org.opencontainers.image.ref.name=${CI_COMMIT_SHA}" 
      --label "org.opencontainers.image.title={{ CI_PROJECT_NAME|capitalize }}" 
      --label "org.opencontainers.image.description={% if CI_PROJECT_BLURB is defined %}{{ CI_PROJECT_BLURB | replace('"', '') | replace('\n', '  ') }}{% else %}{{ CI_PROJECT_NAME }} image by {{ CI_PROJECT_DOMAIN_NAME_SHORT }}{% endif %}" 
      --no-cache --pull -t ${DOCKERHUB_IMAGE}:${CI_COMMIT_SHA}
      .

## Build Docker container local templating CI runs
{% if CI_PROJECT_NAME == "docker-ci-builder" %}
build-ci-image:
   stage: build
   script:
   - >
      DOCKER_BUILDKIT=1 docker build
      --label "org.opencontainers.image.created=${CI_COMMIT_TIMESTAMP}" 
      --label "org.opencontainers.image.authors={{ CI_PROJECT_DOMAIN }}" 
      --label "org.opencontainers.image.url={{ CI_PROJECT_URL }}/container_registry" 
      --label "org.opencontainers.image.documentation={{ CI_PROJECT_DOCS_URL }}/images/docker-{{ CI_PROJECT_NAME }}" 
      --label "org.opencontainers.image.source={{ CI_PROJECT_URL }}" 
      --label "org.opencontainers.image.revision=${CI_COMMIT_SHA}" 
      --label "org.opencontainers.image.vendor={{ CI_PROJECT_DOMAIN }}" 
      --label "org.opencontainers.image.licenses={{ CI_PROJECT_LICENSE }}" 
      --label "org.opencontainers.image.ref.name=${CI_COMMIT_SHA}" 
      --label "org.opencontainers.image.title={{ CI_PROJECT_NAME|capitalize }}" 
      --label "org.opencontainers.image.description={% if CI_PROJECT_BLURB is defined %}{{ CI_PROJECT_BLURB | replace('"', '') | replace('\n', '  ') }}{% else %}{{ CI_PROJECT_NAME }} image by {{ CI_PROJECT_DOMAIN_NAME_SHORT }}{% endif %}" 
      --no-cache --pull -t ${DOCKERHUB_IMAGE}-local:${CI_COMMIT_SHA}
      .
{% endif %}

## Add packages to Scarf.sh package registry
scarf-setup:
   stage: registry-setup
   script:
   - |
      echo PACKAGE_UUID="\"$(curl -X GET -H "Authorization: Bearer ${SCARF_TOKEN}" https://scarf.sh/api/v1/organizations/{{ CI_PROJECT_DOMAIN_NAME_SHORT }}/packages | jq -r '.[] | select(.name=="{{ CI_PROJECT_DOMAIN_NAME_SHORT }}/{{ CI_PROJECT_NAME }}") | .uuid')"\"
      if [ -z "${PACKAGE_UUID}" ];
      then
         echo "Adding package to Scarf.sh"
         curl --location --request POST 'https://scarf.sh/api/v1/organizations/{{ CI_PROJECT_DOMAIN_NAME_SHORT }}/packages/' \
         --header "Content-Type: application/json" \
         --header "Authorization: Bearer ${SCARF_TOKEN}" \
         --data-raw '{
           "name": "{{ CI_PROJECT_DOMAIN_NAME_SHORT }}/{{ CI_PROJECT_NAME }}",
           "shortDescription": "{{ CI_PROJECT_DESCRIPTION }}",
           "libraryType": "docker",
           "website": "{{ CI_PROJECT_URL }}",
           "backendUrl": "https://registry-1.docker.io/{{ CI_PROJECT_DOMAIN_NAME_SHORT }}/{{ CI_PROJECT_NAME }}",
           "publicUrl": "{{ CI_PROJECT_REGISTRY_URL }}/{{ CI_PROJECT_DOMAIN_NAME_SHORT }}/{{ CI_PROJECT_NAME }}"
      }' || :
      else
         echo "Package already exists on Scarf.sh"
      fi